// 実際に使えるPDFと画像ファイル生成
// jsPDFとCanvasを使用した本格的なファイル生成

import { jsPDF } from 'jspdf';

export interface RealFileProgress {
  current: number;
  total: number;
  percentage: number;
  speed: number;
  estimatedTimeLeft: number;
  phase: 'preparing' | 'generating' | 'finalizing' | 'complete';
}

export interface RealFileOptions {
  progressCallback?: (progress: RealFileProgress) => void;
  abortSignal?: AbortSignal;
}

/**
 * 実際に使えるファイル生成器
 */
export class RealFileGenerator {
  /**
   * 実際のPDFファイル生成（jsPDF使用）
   */
  async generateRealPDF(
    targetBytes: number,
    options: RealFileOptions = {}
  ): Promise<Blob> {
    const { progressCallback, abortSignal } = options;

    if (progressCallback) {
      progressCallback({
        current: 0,
        total: targetBytes,
        percentage: 0,
        speed: 0,
        estimatedTimeLeft: 0,
        phase: 'preparing',
      });
    }

    const pdf = new jsPDF();
    let currentBytes = 0;
    let pageCount = 0;

    // 青空文庫風のコンテンツを生成
    const sampleTexts = [
      '吾輩は猫である。名前はまだ無い。どこで生まれたかとんと見当がつかぬ。',
      '何でも薄暗いじめじめした所でニャーニャー泣いていた事だけは記憶している。',
      '人間中で一番獰悪な種族であった。この書生というのは時々我々を捕えて煮て食うという話である。',
      'しかしその当時は何という考もなかったから別段恐ろしいとも思わなかった。',
      'ただ彼の掌に載せられてスーと持ち上げられた時何だかフワフワした感じがあったばかりである。',
      'TestData Buddy (TD) は QA エンジニアの最高の相棒です。',
      '効率的なテストデータ生成で、品質向上をサポートします。',
      'このPDFファイルは実際に開くことができる本物のPDFです。',
      'ページを追加して目標サイズまで生成を続けます。',
      'TDくんと一緒に素晴らしいテストデータを作りましょう！',
    ];

    try {
      // 最初のページ設定
      pdf.setFont('helvetica');

      while (currentBytes < targetBytes) {
        if (abortSignal?.aborted) {
          throw new Error('PDF生成がキャンセルされました');
        }

        pageCount++;

        // 新しいページを追加（最初のページ以外）
        if (pageCount > 1) {
          pdf.addPage();
        }

        // ページヘッダー
        pdf.setFontSize(16);
        pdf.text(`TestData Buddy - Large PDF Test (Page ${pageCount})`, 20, 20);

        pdf.setFontSize(12);
        pdf.text(`Generated: ${new Date().toLocaleString()}`, 20, 30);
        pdf.text(`Target Size: ${this.formatBytes(targetBytes)}`, 20, 40);
        pdf.text(`Current Page: ${pageCount}`, 20, 50);

        // コンテンツ生成
        let yPosition = 70;
        const lineHeight = 6;
        const maxLinesPerPage = 35;

        for (let i = 0; i < maxLinesPerPage; i++) {
          const textIndex =
            (pageCount * maxLinesPerPage + i) % sampleTexts.length;
          const lineNumber = pageCount * maxLinesPerPage + i + 1;
          const text = `${lineNumber.toString().padStart(4, '0')}: ${
            sampleTexts[textIndex]
          }`;

          pdf.setFontSize(10);
          pdf.text(text, 20, yPosition);
          yPosition += lineHeight;

          if (yPosition > 280) break; // ページ下部に到達
        }

        // フッター
        pdf.setFontSize(8);
        pdf.text(
          `TD Buddy Generated PDF - Page ${pageCount} - ${new Date().toISOString()}`,
          20,
          290
        );

        // 現在のサイズを推定
        const pdfOutput = pdf.output('arraybuffer');
        currentBytes = pdfOutput.byteLength;

        // プログレス更新
        if (progressCallback) {
          progressCallback({
            current: currentBytes,
            total: targetBytes,
            percentage: Math.min((currentBytes / targetBytes) * 100, 100),
            speed: 0,
            estimatedTimeLeft: 0,
            phase: currentBytes >= targetBytes ? 'finalizing' : 'generating',
          });
        }

        // 目標サイズに達した場合は終了
        if (currentBytes >= targetBytes) break;

        // 小さな遅延でUIブロックを防ぐ
        await new Promise(resolve => setTimeout(resolve, 10));
      }

      // 最終ページに統計情報を追加
      pdf.addPage();
      pdf.setFontSize(14);
      pdf.text('PDF Generation Summary', 20, 20);

      pdf.setFontSize(12);
      pdf.text(`Total Pages: ${pageCount + 1}`, 20, 40);
      pdf.text(`Target Size: ${this.formatBytes(targetBytes)}`, 20, 50);
      pdf.text(`Actual Size: ${this.formatBytes(currentBytes)}`, 20, 60);
      pdf.text(`Generation Date: ${new Date().toLocaleString()}`, 20, 70);
      pdf.text('Generated by TestData Buddy (TD)', 20, 80);

      if (progressCallback) {
        progressCallback({
          current: targetBytes,
          total: targetBytes,
          percentage: 100,
          speed: 0,
          estimatedTimeLeft: 0,
          phase: 'complete',
        });
      }

      // Blobとして返す
      return new Blob([pdf.output('arraybuffer')], { type: 'application/pdf' });
    } catch (error) {
      throw new Error(
        `PDF生成エラー: ${
          error instanceof Error ? error.message : '不明なエラー'
        }`
      );
    }
  }

  /**
   * 実際のPNG画像生成（Canvas使用）
   */
  async generateRealPNG(
    targetBytes: number,
    options: RealFileOptions = {}
  ): Promise<Blob> {
    const { progressCallback, abortSignal } = options;

    if (progressCallback) {
      progressCallback({
        current: 0,
        total: targetBytes,
        percentage: 0,
        speed: 0,
        estimatedTimeLeft: 0,
        phase: 'preparing',
      });
    }

    // 目標サイズに基づいて画像サイズを計算
    const estimatedPixels = Math.sqrt(targetBytes / 4); // RGBA = 4 bytes per pixel
    const width = Math.max(100, Math.floor(estimatedPixels));
    const height = Math.max(100, Math.floor(estimatedPixels));

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    if (!ctx) {
      throw new Error('Canvas context を取得できませんでした');
    }

    try {
      // 背景グラデーション
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, '#3B82F6'); // TD Blue
      gradient.addColorStop(0.5, '#10B981'); // TD Green
      gradient.addColorStop(1, '#8B5CF6'); // TD Purple

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      if (progressCallback) {
        progressCallback({
          current: targetBytes * 0.3,
          total: targetBytes,
          percentage: 30,
          speed: 0,
          estimatedTimeLeft: 0,
          phase: 'generating',
        });
      }

      // TDロゴ風の図形を描画
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(width, height) / 6;

      // 円形のTDロゴ
      ctx.fillStyle = '#FFFFFF';
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.fill();

      // TD文字
      ctx.fillStyle = '#1F2937';
      ctx.font = `bold ${radius / 2}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('TD', centerX, centerY);

      if (progressCallback) {
        progressCallback({
          current: targetBytes * 0.6,
          total: targetBytes,
          percentage: 60,
          speed: 0,
          estimatedTimeLeft: 0,
          phase: 'generating',
        });
      }

      // ランダムパターンで容量を増やす
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        if (abortSignal?.aborted) {
          throw new Error('PNG生成がキャンセルされました');
        }

        // ノイズを追加して容量を増やす
        const noise = Math.random() * 50 - 25;
        data[i] = Math.max(0, Math.min(255, data[i] + noise)); // R
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
        // Alpha値は変更しない
      }

      ctx.putImageData(imageData, 0, 0);

      if (progressCallback) {
        progressCallback({
          current: targetBytes * 0.9,
          total: targetBytes,
          percentage: 90,
          speed: 0,
          estimatedTimeLeft: 0,
          phase: 'finalizing',
        });
      }

      // Blobに変換
      return new Promise((resolve, reject) => {
        canvas.toBlob(
          blob => {
            if (blob) {
              if (progressCallback) {
                progressCallback({
                  current: targetBytes,
                  total: targetBytes,
                  percentage: 100,
                  speed: 0,
                  estimatedTimeLeft: 0,
                  phase: 'complete',
                });
              }
              resolve(blob);
            } else {
              reject(new Error('PNG生成に失敗しました'));
            }
          },
          'image/png',
          1.0
        );
      });
    } catch (error) {
      throw new Error(
        `PNG生成エラー: ${
          error instanceof Error ? error.message : '不明なエラー'
        }`
      );
    }
  }

  /**
   * 実際のJPEG画像生成
   */
  async generateRealJPEG(
    targetBytes: number,
    options: RealFileOptions = {}
  ): Promise<Blob> {
    const { progressCallback, abortSignal } = options;

    // PNG生成と同様の処理だが、JPEG形式で出力
    const canvas = document.createElement('canvas');

    // 目標サイズに基づいて画像サイズを計算（JPEGは圧縮されるので大きめに）
    const estimatedPixels = Math.sqrt(targetBytes * 2);
    const width = Math.max(200, Math.floor(estimatedPixels));
    const height = Math.max(200, Math.floor(estimatedPixels));

    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    if (!ctx) {
      throw new Error('Canvas context を取得できませんでした');
    }

    try {
      // カラフルなグラデーション背景
      const gradient = ctx.createRadialGradient(
        width / 2,
        height / 2,
        0,
        width / 2,
        height / 2,
        Math.min(width, height) / 2
      );
      gradient.addColorStop(0, '#FF6B6B'); // Red
      gradient.addColorStop(0.3, '#4ECDC4'); // Teal
      gradient.addColorStop(0.6, '#45B7D1'); // Blue
      gradient.addColorStop(1, '#96CEB4'); // Green

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      // 複雑なパターンを描画して容量を増やす
      for (let i = 0; i < 100; i++) {
        if (abortSignal?.aborted) {
          throw new Error('JPEG生成がキャンセルされました');
        }

        const x = Math.random() * width;
        const y = Math.random() * height;
        const radius = Math.random() * 50 + 10;

        ctx.fillStyle = `hsla(${Math.random() * 360}, 70%, 60%, 0.3)`;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();

        if (progressCallback && i % 20 === 0) {
          progressCallback({
            current: (i / 100) * targetBytes * 0.8,
            total: targetBytes,
            percentage: (i / 100) * 80,
            speed: 0,
            estimatedTimeLeft: 0,
            phase: 'generating',
          });
        }
      }

      // TDロゴを中央に配置
      const centerX = width / 2;
      const centerY = height / 2;
      const logoSize = Math.min(width, height) / 8;

      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 3;
      ctx.font = `bold ${logoSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      ctx.strokeText('TD', centerX, centerY);
      ctx.fillText('TD', centerX, centerY);

      // JPEG品質を調整して目標サイズに近づける
      let quality = 0.9;

      return new Promise((resolve, reject) => {
        const tryGenerate = () => {
          canvas.toBlob(
            generatedBlob => {
              if (generatedBlob) {
                // サイズが目標に近い場合は完了
                if (
                  Math.abs(generatedBlob.size - targetBytes) <
                  targetBytes * 0.1
                ) {
                  if (progressCallback) {
                    progressCallback({
                      current: targetBytes,
                      total: targetBytes,
                      percentage: 100,
                      speed: 0,
                      estimatedTimeLeft: 0,
                      phase: 'complete',
                    });
                  }
                  resolve(generatedBlob);
                } else if (generatedBlob.size < targetBytes && quality > 0.1) {
                  // サイズが小さすぎる場合は品質を上げる
                  quality = Math.min(1.0, quality + 0.1);
                  tryGenerate();
                } else {
                  // 十分に近いか、これ以上調整できない場合は完了
                  if (progressCallback) {
                    progressCallback({
                      current: targetBytes,
                      total: targetBytes,
                      percentage: 100,
                      speed: 0,
                      estimatedTimeLeft: 0,
                      phase: 'complete',
                    });
                  }
                  resolve(generatedBlob);
                }
              } else {
                reject(new Error('JPEG生成に失敗しました'));
              }
            },
            'image/jpeg',
            quality
          );
        };

        tryGenerate();
      });
    } catch (error) {
      throw new Error(
        `JPEG生成エラー: ${
          error instanceof Error ? error.message : '不明なエラー'
        }`
      );
    }
  }

  private formatBytes(bytes: number): string {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }

    return `${size.toFixed(2)} ${units[unitIndex]}`;
  }
}

/**
 * 実際に使えるファイル生成のエントリーポイント
 */
export async function generateRealFile(
  targetBytes: number,
  fileType: string,
  progressCallback?: (progress: RealFileProgress) => void,
  abortSignal?: AbortSignal
): Promise<Blob> {
  const generator = new RealFileGenerator();

  switch (fileType) {
    case 'pdf':
      return generator.generateRealPDF(targetBytes, {
        progressCallback,
        abortSignal,
      });
    case 'png':
      return generator.generateRealPNG(targetBytes, {
        progressCallback,
        abortSignal,
      });
    case 'jpg':
    case 'jpeg':
      return generator.generateRealJPEG(targetBytes, {
        progressCallback,
        abortSignal,
      });
    default:
      throw new Error(`サポートされていないファイル形式: ${fileType}`);
  }
}
