# TestData Buddy セキュリティガイドライン

## 🔒 セキュリティ方針

### 基本原則
1. **最小権限の原則**: 必要最小限のアクセス権限のみ付与
2. **深層防御**: 複数の防御層による保護
3. **デフォルトセキュア**: 安全な設定をデフォルトとする
4. **定期的な監査**: 継続的なセキュリティチェック

## 🔐 認証・認可

### API キー管理
```typescript
// 環境変数での管理（推奨）
process.env.CLAUDE_API_KEY // ✅ 安全

// ハードコード（禁止）
const apiKey = "sk-ant-api03-..."; // ❌ 危険
```

### セキュアな設定
```typescript
// src/config/security.config.ts
export const securityConfig = {
  // API キー暗号化
  encryption: {
    algorithm: 'aes-256-gcm',
    keyLength: 32,
  },
  
  // レート制限
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15分
    max: 100, // リクエスト上限
  },
  
  // CORS設定
  cors: {
    origin: process.env.NODE_ENV === 'production' 
      ? ['http://localhost:3000'] 
      : true,
    credentials: true,
  },
  
  // セッション設定
  session: {
    secret: process.env.SESSION_SECRET,
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24時間
  },
};
```

## 🛡️ 入力検証・サニタイゼーション

### バリデーション実装
```typescript
// src/common/pipes/validation.pipe.ts
import { ValidationPipe } from '@nestjs/common';
import { Transform } from 'class-transformer';
import { IsString, IsInt, Min, Max, Matches } from 'class-validator';

export class PasswordRequestDto {
  @IsInt()
  @Min(4)
  @Max(128)
  length: number;

  @IsString()
  @Matches(/^[a-zA-Z0-9!@#$%^&*()_+\-=\[\]{}|;:,.<>?]*$/)
  @Transform(({ value }) => value?.trim())
  customCharset?: string;

  @IsInt()
  @Min(1)
  @Max(100)
  count: number = 1;
}

// グローバル適用
app.useGlobalPipes(new ValidationPipe({
  transform: true,
  whitelist: true,
  forbidNonWhitelisted: true,
  disableErrorMessages: process.env.NODE_ENV === 'production',
}));
```

### SQLインジェクション対策
```typescript
// TypeORM使用時（推奨）
const users = await userRepository.find({
  where: { email: userEmail } // ✅ 自動エスケープ
});

// 生SQL使用時（必要な場合のみ）
const result = await query(
  'SELECT * FROM users WHERE email = $1', 
  [userEmail] // ✅ パラメータ化クエリ
);

// 文字列結合（禁止）
const sql = `SELECT * FROM users WHERE email = '${userEmail}'`; // ❌ 危険
```

## 🔒 データ保護

### 機密データ暗号化
```typescript
// src/common/crypto/encryption.service.ts
import * as crypto from 'crypto';

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key = crypto.scryptSync(process.env.ENCRYPTION_KEY!, 'salt', 32);

  encrypt(text: string): { encrypted: string; iv: string; authTag: string } {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key);
    cipher.setAAD(Buffer.from('TestDataBuddy', 'utf8'));

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: cipher.getAuthTag().toString('hex')
    };
  }

  decrypt(encryptedData: { encrypted: string; iv: string; authTag: string }): string {
    const decipher = crypto.createDecipher(this.algorithm, this.key);
    decipher.setAAD(Buffer.from('TestDataBuddy', 'utf8'));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

### ファイル保護
```typescript
// src/modules/file/file.service.ts
@Injectable()
export class FileService {
  private readonly uploadDir = './data/uploads';
  private readonly allowedMimeTypes = [
    'text/csv',
    'application/json',
    'text/xml',
    'image/png',
    'image/jpeg',
    'application/pdf'
  ];

  validateFile(file: Express.Multer.File): void {
    // ファイルサイズチェック
    if (file.size > 100 * 1024 * 1024) { // 100MB
      throw new BadRequestException('ファイルサイズが上限を超えています');
    }

    // MIME タイプチェック
    if (!this.allowedMimeTypes.includes(file.mimetype)) {
      throw new BadRequestException('許可されていないファイル形式です');
    }

    // ファイル名サニタイズ
    const sanitizedName = file.originalname.replace(/[^a-zA-Z0-9.\-_]/g, '');
    if (sanitizedName !== file.originalname) {
      throw new BadRequestException('無効なファイル名です');
    }
  }

  async saveSecurely(file: Express.Multer.File): Promise<string> {
    this.validateFile(file);
    
    // 一時的なユニークファイル名生成
    const uniqueName = `${Date.now()}-${crypto.randomUUID()}.${file.originalname.split('.').pop()}`;
    const filePath = path.join(this.uploadDir, uniqueName);
    
    // 24時間後に自動削除
    setTimeout(() => {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    }, 24 * 60 * 60 * 1000);

    return filePath;
  }
}
```

## 🚦 レート制限・DDoS対策

### Express Rate Limit設定
```typescript
// src/common/middleware/rate-limit.middleware.ts
import rateLimit from 'express-rate-limit';
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export const createRateLimit = (windowMs: number, max: number) => {
  return rateLimit({
    windowMs,
    max,
    message: 'リクエスト数が制限を超えました。しばらく待ってから再試行してください。',
    standardHeaders: true,
    legacyHeaders: false,
    store: new RedisStore({
      client: redis,
      prefix: 'td_rl:',
    }),
  });
};

// 用途別レート制限
export const apiRateLimit = createRateLimit(15 * 60 * 1000, 100); // 15分/100リクエスト
export const aiRateLimit = createRateLimit(60 * 1000, 10); // 1分/10リクエスト
export const fileRateLimit = createRateLimit(60 * 60 * 1000, 20); // 1時間/20リクエスト
```

## 🔍 セキュリティログ・監査

### セキュリティイベント監視
```typescript
// src/common/audit/security-audit.service.ts
@Injectable()
export class SecurityAuditService {
  private readonly logger = new Logger(SecurityAuditService.name);

  logSecurityEvent(event: SecurityEvent): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: event.type,
      severity: event.severity,
      userId: event.userId,
      ip: event.ip,
      userAgent: event.userAgent,
      details: event.details,
    };

    // ログファイルへ記録
    this.logger.warn(`SECURITY_EVENT: ${JSON.stringify(logEntry)}`);

    // 重要度が高い場合はアラート
    if (event.severity === 'HIGH' || event.severity === 'CRITICAL') {
      this.sendAlert(logEntry);
    }
  }

  private async sendAlert(logEntry: any): Promise<void> {
    // Slack、メール、またはその他の通知システムへ送信
    // 実装は環境に応じて調整
  }
}

// 使用例
@Controller('auth')
export class AuthController {
  constructor(private securityAudit: SecurityAuditService) {}

  @Post('login')
  async login(@Req() req: Request, @Body() loginDto: LoginDto) {
    try {
      const result = await this.authService.login(loginDto);
      
      this.securityAudit.logSecurityEvent({
        type: 'LOGIN_SUCCESS',
        severity: 'LOW',
        userId: result.user.id,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        details: { username: loginDto.username }
      });

      return result;
    } catch (error) {
      this.securityAudit.logSecurityEvent({
        type: 'LOGIN_FAILURE',
        severity: 'MEDIUM',
        userId: null,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        details: { username: loginDto.username, error: error.message }
      });

      throw error;
    }
  }
}
```

## 🔐 Claude API セキュリティ

### API キー保護
```typescript
// src/modules/ai/claude-security.service.ts
@Injectable()
export class ClaudeSecurityService {
  private readonly encryptionService: EncryptionService;
  
  constructor() {
    this.encryptionService = new EncryptionService();
  }

  // プロンプトサニタイゼーション
  sanitizePrompt(prompt: string): string {
    return prompt
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // XSS対策
      .replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u3400-\u4DBF]/g, '') // 特殊文字除去
      .slice(0, 4000); // 長さ制限
  }

  // レスポンス検証
  validateResponse(response: any): boolean {
    if (!response || typeof response !== 'object') {
      return false;
    }

    // 期待されるスキーマチェック
    const requiredFields = ['action', 'parameters'];
    return requiredFields.every(field => field in response);
  }

  // API使用量監視
  async checkUsageLimit(userId: string): Promise<boolean> {
    const key = `claude_usage:${userId}:${this.getCurrentHour()}`;
    const usage = await this.redis.get(key) || 0;
    
    return parseInt(usage) < 50; // 1時間あたり50リクエスト制限
  }

  private getCurrentHour(): string {
    return new Date().toISOString().slice(0, 13); // YYYY-MM-DDTHH
  }
}
```

## 🛠️ セキュリティテスト

### 脆弱性テスト
```typescript
// test/security/security.e2e-spec.ts
describe('Security Tests', () => {
  it('SQLインジェクション攻撃を防ぐ', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    
    const response = await request(app.getHttpServer())
      .post('/api/generate/password')
      .send({ length: maliciousInput })
      .expect(400);
      
    expect(response.body.message).toContain('バリデーションエラー');
  });

  it('XSS攻撃を防ぐ', async () => {
    const xssPayload = '<script>alert("XSS")</script>';
    
    const response = await request(app.getHttpServer())
      .post('/api/ai/generate')
      .send({ prompt: xssPayload })
      .expect(400);
  });

  it('レート制限が正常に動作する', async () => {
    // 制限値を超えるリクエストを送信
    const promises = Array.from({ length: 101 }, () =>
      request(app.getHttpServer())
        .get('/api/health')
    );

    const responses = await Promise.all(promises);
    const rateLimitedResponses = responses.filter(r => r.status === 429);
    
    expect(rateLimitedResponses.length).toBeGreaterThan(0);
  });
});
```

## 📋 セキュリティチェックリスト

### 開発時チェック
- [ ] 機密情報をハードコードしていない
- [ ] 入力値の適切なバリデーション
- [ ] SQL クエリのパラメータ化
- [ ] ファイルアップロードの制限
- [ ] エラーメッセージに機密情報を含まない
- [ ] HTTPS/TLSの使用（本番環境）
- [ ] セキュリティヘッダーの設定

### デプロイ前チェック
- [ ] 依存関係の脆弱性スキャン
- [ ] セキュリティテストの実行
- [ ] ログ設定の確認
- [ ] バックアップ・復旧手順の確認
- [ ] 監視・アラート設定

### 運用時チェック
- [ ] 定期的な脆弱性スキャン
- [ ] ログの監視
- [ ] 異常なアクセスパターンの検知
- [ ] 定期的なパスワード・キーの更新
- [ ] セキュリティパッチの適用

## 🚨 インシデント対応

### 対応手順
1. **検知**: 異常なアクティビティを検知
2. **分析**: 影響範囲とリスクレベルを評価
3. **対応**: 適切な対策を実施
4. **復旧**: サービスの正常化
5. **事後分析**: 原因分析と再発防止策

### 緊急連絡先
```typescript
// src/config/emergency-contacts.ts
export const emergencyContacts = {
  security: 'security@testdatabuddy.com',
  technical: 'tech@testdatabuddy.com',
  management: 'admin@testdatabuddy.com',
};
``` 