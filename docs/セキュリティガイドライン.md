# TestData Buddy ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ–¹é‡

### åŸºæœ¬åŸå‰‡
1. **æœ€å°æ¨©é™ã®åŸå‰‡**: å¿…è¦æœ€å°é™ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã®ã¿ä»˜ä¸
2. **æ·±å±¤é˜²å¾¡**: è¤‡æ•°ã®é˜²å¾¡å±¤ã«ã‚ˆã‚‹ä¿è­·
3. **ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚»ã‚­ãƒ¥ã‚¢**: å®‰å…¨ãªè¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹
4. **å®šæœŸçš„ãªç›£æŸ»**: ç¶™ç¶šçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯

## ğŸ” èªè¨¼ãƒ»èªå¯

### API ã‚­ãƒ¼ç®¡ç†
```typescript
// ç’°å¢ƒå¤‰æ•°ã§ã®ç®¡ç†ï¼ˆæ¨å¥¨ï¼‰
process.env.CLAUDE_API_KEY // âœ… å®‰å…¨

// ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ï¼ˆç¦æ­¢ï¼‰
const apiKey = "sk-ant-api03-..."; // âŒ å±é™º
```

### ã‚»ã‚­ãƒ¥ã‚¢ãªè¨­å®š
```typescript
// src/config/security.config.ts
export const securityConfig = {
  // API ã‚­ãƒ¼æš—å·åŒ–
  encryption: {
    algorithm: 'aes-256-gcm',
    keyLength: 32,
  },
  
  // ãƒ¬ãƒ¼ãƒˆåˆ¶é™
  rateLimit: {
    windowMs: 15 * 60 * 1000, // 15åˆ†
    max: 100, // ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸Šé™
  },
  
  // CORSè¨­å®š
  cors: {
    origin: process.env.NODE_ENV === 'production' 
      ? ['http://localhost:3000'] 
      : true,
    credentials: true,
  },
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­å®š
  session: {
    secret: process.env.SESSION_SECRET,
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24æ™‚é–“
  },
};
```

## ğŸ›¡ï¸ å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

### ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
```typescript
// src/common/pipes/validation.pipe.ts
import { ValidationPipe } from '@nestjs/common';
import { Transform } from 'class-transformer';
import { IsString, IsInt, Min, Max, Matches } from 'class-validator';

export class PasswordRequestDto {
  @IsInt()
  @Min(4)
  @Max(128)
  length: number;

  @IsString()
  @Matches(/^[a-zA-Z0-9!@#$%^&*()_+\-=\[\]{}|;:,.<>?]*$/)
  @Transform(({ value }) => value?.trim())
  customCharset?: string;

  @IsInt()
  @Min(1)
  @Max(100)
  count: number = 1;
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«é©ç”¨
app.useGlobalPipes(new ValidationPipe({
  transform: true,
  whitelist: true,
  forbidNonWhitelisted: true,
  disableErrorMessages: process.env.NODE_ENV === 'production',
}));
```

### SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
```typescript
// TypeORMä½¿ç”¨æ™‚ï¼ˆæ¨å¥¨ï¼‰
const users = await userRepository.find({
  where: { email: userEmail } // âœ… è‡ªå‹•ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
});

// ç”ŸSQLä½¿ç”¨æ™‚ï¼ˆå¿…è¦ãªå ´åˆã®ã¿ï¼‰
const result = await query(
  'SELECT * FROM users WHERE email = $1', 
  [userEmail] // âœ… ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒª
);

// æ–‡å­—åˆ—çµåˆï¼ˆç¦æ­¢ï¼‰
const sql = `SELECT * FROM users WHERE email = '${userEmail}'`; // âŒ å±é™º
```

## ğŸ”’ ãƒ‡ãƒ¼ã‚¿ä¿è­·

### æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–
```typescript
// src/common/crypto/encryption.service.ts
import * as crypto from 'crypto';

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key = crypto.scryptSync(process.env.ENCRYPTION_KEY!, 'salt', 32);

  encrypt(text: string): { encrypted: string; iv: string; authTag: string } {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key);
    cipher.setAAD(Buffer.from('TestDataBuddy', 'utf8'));

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: cipher.getAuthTag().toString('hex')
    };
  }

  decrypt(encryptedData: { encrypted: string; iv: string; authTag: string }): string {
    const decipher = crypto.createDecipher(this.algorithm, this.key);
    decipher.setAAD(Buffer.from('TestDataBuddy', 'utf8'));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

### ãƒ•ã‚¡ã‚¤ãƒ«ä¿è­·
```typescript
// src/modules/file/file.service.ts
@Injectable()
export class FileService {
  private readonly uploadDir = './data/uploads';
  private readonly allowedMimeTypes = [
    'text/csv',
    'application/json',
    'text/xml',
    'image/png',
    'image/jpeg',
    'application/pdf'
  ];

  validateFile(file: Express.Multer.File): void {
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
    if (file.size > 100 * 1024 * 1024) { // 100MB
      throw new BadRequestException('ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒä¸Šé™ã‚’è¶…ãˆã¦ã„ã¾ã™');
    }

    // MIME ã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
    if (!this.allowedMimeTypes.includes(file.mimetype)) {
      throw new BadRequestException('è¨±å¯ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚º
    const sanitizedName = file.originalname.replace(/[^a-zA-Z0-9.\-_]/g, '');
    if (sanitizedName !== file.originalname) {
      throw new BadRequestException('ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«åã§ã™');
    }
  }

  async saveSecurely(file: Express.Multer.File): Promise<string> {
    this.validateFile(file);
    
    // ä¸€æ™‚çš„ãªãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ
    const uniqueName = `${Date.now()}-${crypto.randomUUID()}.${file.originalname.split('.').pop()}`;
    const filePath = path.join(this.uploadDir, uniqueName);
    
    // 24æ™‚é–“å¾Œã«è‡ªå‹•å‰Šé™¤
    setTimeout(() => {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    }, 24 * 60 * 60 * 1000);

    return filePath;
  }
}
```

## ğŸš¦ ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ»DDoSå¯¾ç­–

### Express Rate Limitè¨­å®š
```typescript
// src/common/middleware/rate-limit.middleware.ts
import rateLimit from 'express-rate-limit';
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export const createRateLimit = (windowMs: number, max: number) => {
  return rateLimit({
    windowMs,
    max,
    message: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°ãŒåˆ¶é™ã‚’è¶…ãˆã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚',
    standardHeaders: true,
    legacyHeaders: false,
    store: new RedisStore({
      client: redis,
      prefix: 'td_rl:',
    }),
  });
};

// ç”¨é€”åˆ¥ãƒ¬ãƒ¼ãƒˆåˆ¶é™
export const apiRateLimit = createRateLimit(15 * 60 * 1000, 100); // 15åˆ†/100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
export const aiRateLimit = createRateLimit(60 * 1000, 10); // 1åˆ†/10ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
export const fileRateLimit = createRateLimit(60 * 60 * 1000, 20); // 1æ™‚é–“/20ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
```

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ãƒ»ç›£æŸ»

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆç›£è¦–
```typescript
// src/common/audit/security-audit.service.ts
@Injectable()
export class SecurityAuditService {
  private readonly logger = new Logger(SecurityAuditService.name);

  logSecurityEvent(event: SecurityEvent): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type: event.type,
      severity: event.severity,
      userId: event.userId,
      ip: event.ip,
      userAgent: event.userAgent,
      details: event.details,
    };

    // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸è¨˜éŒ²
    this.logger.warn(`SECURITY_EVENT: ${JSON.stringify(logEntry)}`);

    // é‡è¦åº¦ãŒé«˜ã„å ´åˆã¯ã‚¢ãƒ©ãƒ¼ãƒˆ
    if (event.severity === 'HIGH' || event.severity === 'CRITICAL') {
      this.sendAlert(logEntry);
    }
  }

  private async sendAlert(logEntry: any): Promise<void> {
    // Slackã€ãƒ¡ãƒ¼ãƒ«ã€ã¾ãŸã¯ãã®ä»–ã®é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã¸é€ä¿¡
    // å®Ÿè£…ã¯ç’°å¢ƒã«å¿œã˜ã¦èª¿æ•´
  }
}

// ä½¿ç”¨ä¾‹
@Controller('auth')
export class AuthController {
  constructor(private securityAudit: SecurityAuditService) {}

  @Post('login')
  async login(@Req() req: Request, @Body() loginDto: LoginDto) {
    try {
      const result = await this.authService.login(loginDto);
      
      this.securityAudit.logSecurityEvent({
        type: 'LOGIN_SUCCESS',
        severity: 'LOW',
        userId: result.user.id,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        details: { username: loginDto.username }
      });

      return result;
    } catch (error) {
      this.securityAudit.logSecurityEvent({
        type: 'LOGIN_FAILURE',
        severity: 'MEDIUM',
        userId: null,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        details: { username: loginDto.username, error: error.message }
      });

      throw error;
    }
  }
}
```

## ğŸ” Claude API ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### API ã‚­ãƒ¼ä¿è­·
```typescript
// src/modules/ai/claude-security.service.ts
@Injectable()
export class ClaudeSecurityService {
  private readonly encryptionService: EncryptionService;
  
  constructor() {
    this.encryptionService = new EncryptionService();
  }

  // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
  sanitizePrompt(prompt: string): string {
    return prompt
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // XSSå¯¾ç­–
      .replace(/[^\w\s\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u3400-\u4DBF]/g, '') // ç‰¹æ®Šæ–‡å­—é™¤å»
      .slice(0, 4000); // é•·ã•åˆ¶é™
  }

  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¤œè¨¼
  validateResponse(response: any): boolean {
    if (!response || typeof response !== 'object') {
      return false;
    }

    // æœŸå¾…ã•ã‚Œã‚‹ã‚¹ã‚­ãƒ¼ãƒãƒã‚§ãƒƒã‚¯
    const requiredFields = ['action', 'parameters'];
    return requiredFields.every(field => field in response);
  }

  // APIä½¿ç”¨é‡ç›£è¦–
  async checkUsageLimit(userId: string): Promise<boolean> {
    const key = `claude_usage:${userId}:${this.getCurrentHour()}`;
    const usage = await this.redis.get(key) || 0;
    
    return parseInt(usage) < 50; // 1æ™‚é–“ã‚ãŸã‚Š50ãƒªã‚¯ã‚¨ã‚¹ãƒˆåˆ¶é™
  }

  private getCurrentHour(): string {
    return new Date().toISOString().slice(0, 13); // YYYY-MM-DDTHH
  }
}
```

## ğŸ› ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

### è„†å¼±æ€§ãƒ†ã‚¹ãƒˆ
```typescript
// test/security/security.e2e-spec.ts
describe('Security Tests', () => {
  it('SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒã‚’é˜²ã', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    
    const response = await request(app.getHttpServer())
      .post('/api/generate/password')
      .send({ length: maliciousInput })
      .expect(400);
      
    expect(response.body.message).toContain('ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼');
  });

  it('XSSæ”»æ’ƒã‚’é˜²ã', async () => {
    const xssPayload = '<script>alert("XSS")</script>';
    
    const response = await request(app.getHttpServer())
      .post('/api/ai/generate')
      .send({ prompt: xssPayload })
      .expect(400);
  });

  it('ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹', async () => {
    // åˆ¶é™å€¤ã‚’è¶…ãˆã‚‹ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
    const promises = Array.from({ length: 101 }, () =>
      request(app.getHttpServer())
        .get('/api/health')
    );

    const responses = await Promise.all(promises);
    const rateLimitedResponses = responses.filter(r => r.status === 429);
    
    expect(rateLimitedResponses.length).toBeGreaterThan(0);
  });
});
```

## ğŸ“‹ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### é–‹ç™ºæ™‚ãƒã‚§ãƒƒã‚¯
- [ ] æ©Ÿå¯†æƒ…å ±ã‚’ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã—ã¦ã„ãªã„
- [ ] å…¥åŠ›å€¤ã®é©åˆ‡ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
- [ ] SQL ã‚¯ã‚¨ãƒªã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–
- [ ] ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®åˆ¶é™
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æ©Ÿå¯†æƒ…å ±ã‚’å«ã¾ãªã„
- [ ] HTTPS/TLSã®ä½¿ç”¨ï¼ˆæœ¬ç•ªç’°å¢ƒï¼‰
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®è¨­å®š

### ãƒ‡ãƒ—ãƒ­ã‚¤å‰ãƒã‚§ãƒƒã‚¯
- [ ] ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
- [ ] ãƒ­ã‚°è¨­å®šã®ç¢ºèª
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©æ—§æ‰‹é †ã®ç¢ºèª
- [ ] ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š

### é‹ç”¨æ™‚ãƒã‚§ãƒƒã‚¯
- [ ] å®šæœŸçš„ãªè„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
- [ ] ãƒ­ã‚°ã®ç›£è¦–
- [ ] ç•°å¸¸ãªã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œçŸ¥
- [ ] å®šæœŸçš„ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ»ã‚­ãƒ¼ã®æ›´æ–°
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ‘ãƒƒãƒã®é©ç”¨

## ğŸš¨ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

### å¯¾å¿œæ‰‹é †
1. **æ¤œçŸ¥**: ç•°å¸¸ãªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’æ¤œçŸ¥
2. **åˆ†æ**: å½±éŸ¿ç¯„å›²ã¨ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ã‚’è©•ä¾¡
3. **å¯¾å¿œ**: é©åˆ‡ãªå¯¾ç­–ã‚’å®Ÿæ–½
4. **å¾©æ—§**: ã‚µãƒ¼ãƒ“ã‚¹ã®æ­£å¸¸åŒ–
5. **äº‹å¾Œåˆ†æ**: åŸå› åˆ†æã¨å†ç™ºé˜²æ­¢ç­–

### ç·Šæ€¥é€£çµ¡å…ˆ
```typescript
// src/config/emergency-contacts.ts
export const emergencyContacts = {
  security: 'security@testdatabuddy.com',
  technical: 'tech@testdatabuddy.com',
  management: 'admin@testdatabuddy.com',
};
``` 