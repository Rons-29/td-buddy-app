AI連携型テストデータ生成ツール開発ドキュメント
このドキュメントは、QAエンジニアであるお客様のニーズに基づき、テスト実施に必要な様々なテストデータをAI連携によって自然言語で生成・操作可能にするシステム「AI連携型テストデータ生成ツール」のシステム開発計画をまとめたものです。

1. システム概要
本システムは、QAエンジニアがテスト実施時に必要となる多様なテストデータを、自然言語による指示で効率的に生成することを目的とします。特に、パスワード生成、容量テストファイル作成、擬似個人情報生成などの機能を網羅し、AI (Claude) およびIDE (Cursor) との連携を通じて、直感的かつ柔軟なデータ生成プロセスを実現します。

最終的には、ローカル環境で完結し、運用コストをゼロに抑えることを目指しますが、MCP (Model Context Protocol) サーバーの概念を導入することで、将来的な拡張性やより高度なAI連携に対応できる基盤を構築します。

1.1. プロジェクト名とサービス名
このプロジェクトは、開発フェーズでは「TestDataGen AI」というプロジェクト名で進行します。

そして、QAエンジニアの皆様に親しんで使っていただけるサービスとして、「TestData Buddy」というサービス名を採用します。

サービス名: TestData Buddy (テストデータ バディ)

略称: TD (ティーディー)

キャラクター案:

名前: TD (ティーディー)

見た目: 小さくて賢そうなロボット、または friendly な犬のようなキャラクター。いつもQAエンジニアの隣に寄り添っていて、困っているとサッとデータを生成してくれる。頭からピコピコとデータが飛び出すイメージ。

性格: 忠実、頼りになる、少しお茶目。

2. 技術スタック
フロントエンド (Web UI): Remix / TypeScript

ユーザーインターフェースを提供し、テストデータ生成ツールの設定や結果表示を行います。

バックエンド / MCPサーバー (API & Core Logic): NestJS / TypeScript

テストデータ生成のコアロジックを実装し、各種APIを提供します。

MCPプロトコルを実装し、AIからの要求を解釈し、テストデータ生成ツールをオーケストレーションします。

Claude APIとの連携もこの層で行います。

データベース: SQLite

テストデータ生成ツールの設定情報、スキーマ定義、および生成履歴などの永続化に利用します。ファイルベースのため、ローカル環境での動作に最適です。

AI連携: Claude (Anthropic API)

自然言語によるテストデータ生成指示の解釈、複雑な条件指定の構造化に利用します。

IDE連携: Cursor

IDE内からのツール呼び出し、生成データのテストコードへの埋め込みなど、QAエンジニアのワークフローに統合します。

3. システムアーキテクチャ
本システムは、クライアントサイドのWeb UI、MCPサーバーとして機能するバックエンド、そしてSQLiteデータベースで構成されます。AI (Claude) はMCPサーバーを通じて連携し、IDE (Cursor) はユーザーインターフェースとしてMCPサーバーと連携します。

graph TD
    User[QAエンジニア] -->|操作| Cursor(IDE - Cursor)
    Cursor -->|MCPプロトコル要求 (自然言語指示を含む)| MCP_Server(MCPサーバー: NestJS App)
    MCP_Server -->|Claude API呼び出し| Claude(外部AI: Claude API)
    Claude -->|構造化されたデータ生成パラメータ| MCP_Server
    MCP_Server -->|テストデータ生成ロジック呼び出し| TestDataGenerator[テストデータ生成ロジック (NestJS)]
    TestDataGenerator -->|読み書き| SQLite[SQLite DB (data.sqlite)]
    TestDataGenerator -->|生成データ| MCP_Server
    MCP_Server -->|生成結果/ステータス| Cursor
    Cursor -->|生成結果表示/テストコードへの埋め込み| User
    UI[Remix (Web UI)] -->|Webブラウザ経由| MCP_Server
    UI -->|設定/結果表示| User

    subgraph Local Environment
        Cursor
        UI
        MCP_Server
        TestDataGenerator
        SQLite
    end
    subgraph External Service
        Claude
    end


各コンポーネントの役割
Remix (Web UI):

ブラウザ上で動作し、テストデータ生成ツールのGUIを提供します。

ユーザーが手動で設定を調整したり、生成履歴を確認したりするためのインターフェースです。

NestJSのAPIエンドポイントを呼び出し、結果を表示します。

NestJSアプリケーション (MCPサーバー):

MCPプロトコルハンドラー: CursorやClaudeからのMCPプロトコルに準拠したリクエストを受け取り、解析します。

オーケストレーター: リクエストの内容（自然言語指示や構造化されたパラメータ）を解釈し、適切なテストデータ生成ロジックを呼び出します。

AIゲートウェイ: Claude APIを呼び出し、自然言語の複雑な指示を構造化されたデータ生成パラメータに変換する役割を担います。

テストデータ生成エンジン: パスワード生成、ファイル生成、個人情報生成などのコアロジックを内包します。

データ永続化層: SQLiteデータベースとの連携を行い、設定や履歴を保存・読み込みます。

ファイル出力: 生成されたテストデータをローカルファイルシステムに保存し、ダウンロード可能なURLを提供します。

SQLite DB:

NestJSアプリケーションが利用するファイルベースのデータベース。

テストデータ生成のスキーマ定義、ツールの設定、過去の生成履歴などを保存します。

Claude API:

自然言語の複雑な指示を、テストデータ生成ツールが理解できる具体的なパラメータに変換するために利用されます。

「〜のような条件で〜を生成して」といった曖昧な指示を、NestJSのAPIが求めるJSON形式に落とし込む橋渡し役を担います。

Cursor (IDE):

QAエンジニアが日頃使用するIDEであり、ここから自然言語でAI連携型のテストデータ生成をトリガーします。

CursorのAIチャット機能やカスタムコマンドの拡張性により、NestJSのMCPサーバーと直接連携し、生成結果をテストコードやテストケース記述に直接利用できるようにします。

4. 機能一覧と詳細設計
4.1. パスワード生成ツール
概要: 指定された文字数、使用文字種（英大文字、英小文字、数字、記号）に基づいて安全なランダムパスワードを生成。強度表示も可能。

UI (Remix): パスワード長入力、文字種チェックボックス、生成ボタン、生成結果表示、強度メーター。

API (NestJS): /api/generate/password

Request: {"length": 12, "includeUpper": true, "includeLower": true, "includeNumbers": true, "includeSymbols": true}

Response: {"password": "aB1$cDeF2Ghi"}

ロジック: cryptoモジュールを使用し、安全な乱数で指定文字種からパスワードを生成。パスワード強度はフロントエンド (zxcvbn) またはバックエンドで計算し、UIに表示。

4.2. テキストデータ生成（いろんな文字種）
概要: 指定された文字数、文字種（ひらがな、カタカナ、漢字、英字、数字、記号、絵文字など）のランダムなテキストを生成。lorem ipsumのようなダミーテキスト生成もサポート。

UI (Remix): 生成文字数入力、文字種チェックボックス、生成ボタン、生成結果表示。

API (NestJS): /api/generate/text

Request: {"length": 100, "charSets": ["hiragana", "kanji", "alpha", "numeric"], "useLoremIpsum": false}

Response: {"text": "これはテスト用のテキストです。ABC123..."}

ロジック: 内部に文字種ごとの文字セットを定義。指定されたセットからランダムに文字を選択・結合。faker-js/fakerでダミーテキストも生成。

4.3. 旧字体データ作成
概要: 新字体テキストを旧字体に変換、または旧字体を含むランダムなテキストを生成。

UI (Remix): 新字体テキスト入力欄、変換ボタン、変換後旧字体表示。または、旧字体文字数指定、生成ボタン、結果表示。

API (NestJS): /api/convert/old-kanji (変換) / /api/generate/old-kanji-text (生成)

Request (変換): {"text": "横浜"}

Response (変換): {"convertedText": "橫濱"}

Request (生成): {"length": 50}

Response (生成): {"text": "吾輩は猫である。"}

ロジック: 旧字体・新字体のマッピング辞書を実装。網羅性は課題となるが、テストデータ用途であれば限定的な対応でも価値あり。

4.4. いろんなファイル作成（ちゃんと中身がある）
概要: 指定されたファイル形式（CSV, JSON, XML, TXT, ダミー画像/PDF）で、指定されたサイズまたはレコード数の中身があるファイルを生成。

UI (Remix): ファイル形式選択、サイズ指定/レコード数指定、ダウンロードボタン。

API (NestJS): /api/generate/file

Request: {"format": "csv", "rowCount": 1000, "schema": [{"name": "id", "type": "uuid"}, {"name": "name", "type": "personalInfo.fullName"}]}

Response: {"downloadUrl": "/downloads/generated_file.csv"} (一時的なダウンロードURL)

ロジック:

リクエストされた形式とスキーマに基づいて、faker-js/fakerや上記生成ロジックを組み合わせてダミーデータを生成。

CSV: csv-stringify。

JSON: JSON.stringify()。

XML: xmlbuilder2。

画像: sharpやjimpで単色画像やシンプルなパターンを生成。

PDF: pdfkitでダミーテキストやページ数指定のPDFを生成。

生成したファイルを一時ディレクトリに保存し、そのURLを返す。

4.5. カラー抽出
概要: 画像から主要な色を抽出、またはランダムな色コード（HEX, RGBなど）を生成。

UI (Remix): 画像アップロード欄（カラー抽出）、ランダムカラー生成ボタン、生成された色コード表示、色見本表示。

API (NestJS): /api/extract/colors (画像から) / /api/generate/color (ランダム生成)

Request (抽出): (画像ファイルデータ)

Response (抽出): {"colors": ["#RRGGBB", "#AABBCC"]}

Request (生成): {"format": "hex"}

Response (生成): {"color": "#A1B2C3"}

ロジック:

抽出: sharpとnode-vibrantを組み合わせて主要色を抽出。

生成: 乱数でHEX/RGB値を生成。

4.6. 擬似個人情報作成ツール
概要: 氏名、住所、電話番号、メールアドレス、生年月日などの擬似個人情報を、日本語のリアリティを持たせて生成。

UI (Remix): 生成件数指定、生成ボタン、生成結果リスト表示、CSV/JSONダウンロードボタン。

API (NestJS): /api/generate/personal-info

Request: {"count": 10, "fields": ["fullName", "address", "phoneNumber", "email"]}

Response: [{"fullName": "山田 太郎", "address": "東京都渋谷区...", ...}]

ロジック: faker-js/fakerの日本語ロケール (ja) をフル活用。より複雑な整合性（例: 郵便番号と住所の一致）が必要な場合は、追加のデータセットやロジックを実装。

4.7. その他のテスト実施で使いそうなやつ
UUID/GUID 生成:

API: /api/generate/uuid

ロジック: uuidライブラリ。

日付・時刻生成:

API: /api/generate/datetime

ロジック: date-fnsやluxonで、指定範囲内、フォーマットでの生成。

JSON Schema Generator (簡易版):

API: /api/generate/json-schema

ロジック: 入力JSONを解析し、簡易的なスキーマを推論。

ランダム数値生成:

API: /api/generate/number

ロジック: 範囲、小数点以下桁数、分布指定（例: 正規分布、一様分布）。

真偽値（boolean）生成:

API: /api/generate/boolean

ロジック: 指定確率でtrue/falseを生成。

4.8. AI (Claude) との連携
概要: 自然言語の複雑な指示を、テストデータ生成ツールが理解できる具体的なパラメータに変換し、データ生成をトリガーします。

API (NestJS): /api/ai/generate-test-data (仮)

Request: {"prompt": "パスワードを15文字で、記号と数字を混ぜて5つ生成して"} (Cursorからの自然言語指示)

Response: {"passwords": ["...", "...", ...], "rawApiResponse": {"... Claudeのレスポンス ..."}}

ロジック:

Cursorから自然言語のpromptを受け取る。

このpromptをClaude APIに送信する。この際、Claudeに対して「これはテストデータ生成ツールのリクエストであり、以下のJSONスキーマに従って出力せよ」という指示（システムプロンプト）を与えることが重要。

Claudeからの応答（期待するは構造化されたJSON、例: {"action": "generatePassword", "parameters": {"length": 15, "includeSymbols": true, "includeNumbers": true, "count": 5}}）を受け取る。

このJSONを解析し、適切なテストデータ生成ロジック（例: passwordService.generate()）を呼び出す。

生成結果をCursorに返す。

MCPプロトコルの詳細化: AIがNestJSのAPIに送るJSONリクエスト/レスポンスのプロトコルは、packages/commonにて、具体的なアクションタイプ（例: GeneratePasswordAction, CreateFileAction）とその対応するパラメータを網羅的に定義したTypeScriptのインターフェース/型として設計します。

プロンプトエンジニアリング: Claudeが正確なJSONを生成できるように、細かくプロンプトを調整するフェーズが最も重要で、繰り返し試行錯誤が必要になります。

4.9. IDE (Cursor) との連携
概要: QAエンジニアがCursor内で自然言語で指示を入力し、テストデータ生成をトリガーし、結果をテストコードやテストケース記述に直接利用できるようにします。

方法:

CursorのAIチャット/カスタムコマンド: Cursor内でユーザーが自然言語で指示を入力。

Cursorがその指示を直接、あるいはNestJSのMCPサーバー経由でClaudeに送信。

ClaudeがNestJSのMCPプロトコルに従ったリクエストJSONを生成。

CursorがそのJSONをNestJSのMCPサーバーに送信。

NestJSが結果をCursorに返し、Cursorがそれをエディタに挿入、またはチャットで表示。

Cursorの拡張機能: VS Codeの拡張機能として、テストデータ生成ツールへのショートカットやカスタム入力フォームを開発し、NestJSのAPIを呼び出す方法も考えられます。これはより高度な連携ですが、UI/UXを向上させます。

課題: Cursorの外部API連携やカスタム機能の自由度、ドキュメントの成熟度を調査し、最適な連携方法を見つける必要があります。この点は、開発フェーズ3および4の開始時に詳細な技術調査を最優先で行う必要があります。

5. 開発フェーズとロードマップ
以下に、段階的な開発ロードマップを提案します。

フェーズ 1: 基盤構築と主要機能のMVP (2-4週間)

環境構築: モノレポ構成 (pnpm workspace)、RemixとNestJSプロジェクトのセットアップ。

データベース: SQLiteのセットアップ、TypeORM/Prisma導入、基本的なスキーマ定義の永続化。

機能実装 (GUIから操作):

パスワード生成ツール

テキストデータ生成（基本的な文字種）

擬似個人情報作成ツール（基本的なフィールド）

Remix UI: 各機能の基本的な入力フォームと結果表示。初期段階で各機能のUIモックアップ（Figma等）を作成し、ユーザー体験を検証します。

NestJS API: 各機能のRESTful APIエンドポイント。

目標: GUI経由で手動で主要なテストデータが生成できるようになる。

フェーズ 2: 高度なデータ生成機能とファイル出力 (2-3週間)

機能実装:

いろんなファイル作成（CSV, JSON, TXT）

テキストデータ生成（より多様な文字種、ダミーテキスト）

その他テスト実施で使いそうなやつ（UUID, 日付/時刻, ランダム数値, 真偽値）

旧字体データ作成（基本的な変換・生成）

ファイル出力: 生成されたファイルをローカルに保存し、ダウンロード可能な仕組み。

目標: より多様なテストデータに対応し、ファイルとして出力できるようになる。

フェーズ 3: MCPサーバーとしての強化とAI連携 (3-4週間)

MCPプロトコル設計: AIがNestJSのAPIに送るJSONリクエスト/レスポンスのプロトコルを詳細に定義（packages/commonでの型定義を含む）。

NestJSのMCPハンドラー実装: 定義したMCPプロトコルを受け取り、既存のテストデータ生成ロジックを呼び出す共通のエンドポイントを実装。

Claude API連携: NestJSからClaude APIを呼び出すモジュールを実装。自然言語指示をMCPプロトコルに変換するためのプロンプトエンジニアリングを開始。このフェーズでは、Claudeからのレスポンスをモニタリングし、期待通りのJSONが生成されるように、プロンプトを継続的に改善する体制を確立します。

目標: Claude経由で自然言語で指示を出し、NestJSがそれを解釈してテストデータを生成できるようになる。

フェーズ 4: IDE (Cursor) 連携と洗練 (2-3週間)

Cursor連携調査: このフェーズの最優先事項として、CursorがNestJSのMCPサーバーと連携する具体的な方法（APIの呼び出し方、カスタムコマンドの作成、エディタへのテキスト挿入方法など）を詳細に調査・検証します。

Cursor統合実装: Cursorのカスタム機能を利用して、テストデータ生成をトリガーし、結果をIDE内に表示・操作できる仕組みを実装。

UI/UX改善: 全体的な使いやすさ、エラーメッセージ、フィードバック表示などの改善。

目標: Cursorを通じてシームレスにテストデータ生成が行えるようになる。

6. 非機能要件・考慮事項
ローカル環境での動作: 全てのコンポーネント（Remix, NestJS, SQLite）がローカルPC上で完結して動作すること。外部への接続はClaude APIのみ。

パフォーマンス: 大容量ファイル生成時や多数の個人情報生成時にも、PCの許容範囲内で迅速に処理が完了すること。必要に応じてストリーミング処理などを検討。特に容量テストファイル生成など、大量のデータ処理が伴う機能では、プロファイリングツールなどを活用してパフォーマンスボトルネックを特定し、最適化する計画を立てておきます。

セキュリティ:

Claude APIキーはNestJSサーバー側で安全に管理する（環境変数など）。

生成されるテストデータ（特に擬似個人情報）が外部に漏洩しないよう、ローカル環境でのみ処理・保存されることを徹底する。

ファイル出力先ディレクトリの安全性確保。

保守性:

モノレポによるコードの一元管理、共通型定義の活用。

NestJSのモジュール分割、DI（依存性注入）による疎結合な設計。

TypeScriptによる型安全性の確保。

適切なコメント、README、開発ドキュメントの整備。

拡張性: 将来的に新しいテストデータ生成ロジックや、他のAIモデル、IDEとの連携にも対応しやすいアーキテクチャ。

エラーハンドリング: 各層（UI, API, ロジック）で適切なエラーハンドリングを行い、ユーザーに分かりやすい形でフィードバックを返す。APIからのエラーレスポンスの形式（例: {"statusCode": 400, "message": "Invalid input", "errorCode": "E_INVALID_LENGTH"}）や、ユーザーへの表示メッセージのルールを標準化します。

テスト: ユニットテスト、統合テストを導入し、特にデータ生成ロジックの正確性を保証する。

7. レビュー
ドキュメントの評価
このドキュメントは、お客様の要望を網羅し、AI連携型テストデータ生成ツールのシステム開発における主要な要素を非常に具体的に記述できています。特に、MCPサーバーの概念をNestJSのバックエンドに組み込むというアプローチは、AIとの連携をより洗練されたものにする点で優れています。

良い点
要件の網羅性: QAエンジニアのニーズ（パスワード、容量ファイル、擬似個人情報など）と、AI/IDE連携の要望がしっかりと反映されています。

アーキテクチャの明確化: MCPサーバーという概念を導入し、AIとの連携ハブとしてのNestJSの役割が明確にされています。

詳細設計の具体性: 各機能について、UI、API、ロジック、使用ライブラリまで具体的に記述されており、開発に着手しやすいレベルです。

ロードマップの段階性: MVPからAI/IDE連携まで、段階的なフェーズ分けがされており、計画的に開発を進めることができます。

非機能要件への言及: パフォーマンス、セキュリティ、保守性、拡張性といった非機能要件についても触れられており、品質の高いシステム構築への意識が見られます。

改善点・補足事項
これまでの議論で指摘された改善点・補足事項は、ドキュメントの関連セクションに反映され、より詳細かつ具体的な内容となりました。これにより、開発の進行において考慮すべき点がさらに明確になっています。