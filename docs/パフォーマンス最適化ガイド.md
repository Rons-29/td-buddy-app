# TestData Buddy ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã‚¬ã‚¤ãƒ‰

## ğŸ¯ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™

### ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ç›®æ¨™
- **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç”Ÿæˆ**: < 100ms
- **å°è¦æ¨¡ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ** (< 1KB): < 200ms  
- **å€‹äººæƒ…å ±ç”Ÿæˆ** (< 100ä»¶): < 500ms
- **å°è¦æ¨¡ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ** (< 1MB): < 1ç§’
- **å¤§è¦æ¨¡ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ** (< 100MB): < 30ç§’
- **Claude API å‘¼ã³å‡ºã—**: < 3ç§’

### ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ç›®æ¨™
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: < 512MB (é€šå¸¸æ™‚)
- **CPUä½¿ç”¨ç‡**: < 70% (ãƒ”ãƒ¼ã‚¯æ™‚)
- **ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨é‡**: < 1GB (ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«å«ã‚€)

## ğŸš€ Backendæœ€é©åŒ–

### 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–

#### SQLite ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°
```typescript
// src/config/database.config.ts
import { TypeOrmModuleOptions } from '@nestjs/typeorm';

export const databaseConfig: TypeOrmModuleOptions = {
  type: 'sqlite',
  database: './data/td-buddy.sqlite',
  entities: ['dist/**/*.entity{.ts,.js}'],
  synchronize: false,
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–è¨­å®š
  extra: {
    // WALãƒ¢ãƒ¼ãƒ‰ï¼ˆæ›¸ãè¾¼ã¿æ€§èƒ½å‘ä¸Šï¼‰
    pragma: {
      journal_mode: 'WAL',
      synchronous: 'NORMAL',
      cache_size: -64000, // 64MB ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      temp_store: 'MEMORY',
      mmap_size: 268435456, // 256MB mmap
    }
  },
  
  // æ¥ç¶šãƒ—ãƒ¼ãƒ«è¨­å®š
  poolSize: 10,
  keepConnectionAlive: true,
  
  // ãƒ­ã‚°è¨­å®šï¼ˆæœ¬ç•ªã§ã¯ç„¡åŠ¹åŒ–ï¼‰
  logging: process.env.NODE_ENV === 'development' ? 'all' : false,
};
```

#### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
```sql
-- å±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_generation_history_type ON generation_history(type);
CREATE INDEX idx_generation_history_created_at ON generation_history(created_at);
CREATE INDEX idx_generation_history_user_id ON generation_history(user_id);

-- è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_generation_history_user_type_date 
ON generation_history(user_id, type, created_at);

-- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹  
CREATE INDEX idx_file_template_type ON file_template(type);
```

### 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

#### Redis ã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Ÿè£…
```typescript
// src/common/cache/cache.service.ts
import { Injectable } from '@nestjs/common';
import { Redis } from 'ioredis';

@Injectable()
export class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
    });
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const cached = await this.redis.get(key);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      console.warn(`Cache get error for key ${key}:`, error);
      return null;
    }
  }

  async set(key: string, value: any, ttlSeconds = 3600): Promise<void> {
    try {
      await this.redis.setex(key, ttlSeconds, JSON.stringify(value));
    } catch (error) {
      console.warn(`Cache set error for key ${key}:`, error);
    }
  }

  async del(key: string): Promise<void> {
    try {
      await this.redis.del(key);
    } catch (error) {
      console.warn(`Cache delete error for key ${key}:`, error);
    }
  }

  // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ã®å‰Šé™¤
  async deletePattern(pattern: string): Promise<void> {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

#### ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥å®Ÿè£…
```typescript
// src/common/cache/memory-cache.service.ts
import { Injectable } from '@nestjs/common';
import NodeCache from 'node-cache';

@Injectable()
export class MemoryCacheService {
  private cache: NodeCache;

  constructor() {
    this.cache = new NodeCache({
      stdTTL: 600, // 10åˆ†ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆTTL
      checkperiod: 120, // 2åˆ†æ¯ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      maxKeys: 1000, // æœ€å¤§ã‚­ãƒ¼æ•°
    });
  }

  get<T>(key: string): T | undefined {
    return this.cache.get<T>(key);
  }

  set(key: string, value: any, ttl?: number): boolean {
    return this.cache.set(key, value, ttl || 600);
  }

  del(key: string): number {
    return this.cache.del(key);
  }

  flush(): void {
    this.cache.flushAll();
  }

  getStats() {
    return this.cache.getStats();
  }
}
```

### 3. éåŒæœŸå‡¦ç†ãƒ»ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°

#### å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆæœ€é©åŒ–
```typescript
// src/modules/file/file-stream.service.ts
import { Injectable } from '@nestjs/common';
import { Transform, Writable } from 'stream';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';

@Injectable()
export class FileStreamService {
  
  async generateLargeCSV(config: FileGenerationConfig): Promise<string> {
    const outputPath = this.getOutputPath(config);
    const writeStream = createWriteStream(outputPath);
    
    // CSVãƒ˜ãƒƒãƒ€ãƒ¼æ›¸ãè¾¼ã¿
    writeStream.write(this.generateCSVHeader(config.schema) + '\n');
    
    // ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆç”¨ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒ 
    const dataGenerator = new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        const row = this.generateDataRow(config.schema);
        const csvRow = this.formatCSVRow(row);
        callback(null, csvRow + '\n');
      }.bind(this)
    });

    // ãƒãƒƒãƒå‡¦ç†ç”¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ 
    const batchStream = new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        // 1000è¡Œãšã¤ãƒãƒƒãƒå‡¦ç†
        const batch = Array.from({ length: 1000 }, (_, i) => i);
        batch.forEach(row => this.push(row));
        callback();
      }
    });

    try {
      await pipeline(
        this.createNumberStream(config.rowCount),
        batchStream,
        dataGenerator,
        writeStream
      );
      
      return outputPath;
    } catch (error) {
      throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }
  }

  private createNumberStream(count: number) {
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        for (let i = 0; i < count; i += 1000) {
          this.push(i);
        }
        callback();
      }
    });
  }
}
```

### 4. ä¸¦åˆ—å‡¦ç†æœ€é©åŒ–

#### Worker Threadsæ´»ç”¨
```typescript
// src/modules/worker/worker.service.ts
import { Injectable } from '@nestjs/common';
import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { cpus } from 'os';

@Injectable()
export class WorkerService {
  private readonly maxWorkers = cpus().length;

  async processInParallel<T, R>(
    items: T[],
    processingFunction: (item: T) => R,
    chunkSize?: number
  ): Promise<R[]> {
    
    const chunks = this.chunkArray(items, chunkSize || Math.ceil(items.length / this.maxWorkers));
    const workers: Promise<R[]>[] = [];

    for (const chunk of chunks) {
      const workerPromise = new Promise<R[]>((resolve, reject) => {
        const worker = new Worker(__filename, {
          workerData: { chunk, functionString: processingFunction.toString() }
        });

        worker.on('message', resolve);
        worker.on('error', reject);
        worker.on('exit', (code) => {
          if (code !== 0) {
            reject(new Error(`Worker stopped with exit code ${code}`));
          }
        });
      });

      workers.push(workerPromise);
    }

    const results = await Promise.all(workers);
    return results.flat();
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
}

// ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰å‡¦ç†
if (!isMainThread) {
  const { chunk, functionString } = workerData;
  const processingFunction = new Function('return ' + functionString)();
  
  const results = chunk.map(processingFunction);
  parentPort?.postMessage(results);
}
```

## ğŸ¨ Frontendæœ€é©åŒ–

### 1. Remixæœ€é©åŒ–

#### ãƒ­ãƒ¼ãƒ€ãƒ¼æœ€é©åŒ–
```typescript
// app/routes/password.tsx
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { useLoaderData, useFetcher } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
  const headers = new Headers();
  headers.set('Cache-Control', 'public, max-age=300'); // 5åˆ†ã‚­ãƒ£ãƒƒã‚·ãƒ¥

  // å¿…è¦æœ€å°é™ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿å–å¾—
  const config = await getPasswordConfig();
  
  return json({ config }, { headers });
}

// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæœ€é©åŒ–
export default function PasswordPage() {
  const { config } = useLoaderData<typeof loader>();
  const fetcher = useFetcher();
  
  // debounceã•ã‚ŒãŸç”Ÿæˆé–¢æ•°
  const debouncedGenerate = useMemo(
    () => debounce((formData: FormData) => {
      fetcher.submit(formData, { method: 'post' });
    }, 300),
    [fetcher]
  );

  return (
    <div className="space-y-6">
      <PasswordForm onSubmit={debouncedGenerate} />
      {fetcher.data && <PasswordResult data={fetcher.data} />}
    </div>
  );
}
```

#### ãƒãƒ³ãƒ‰ãƒ«æœ€é©åŒ–
```typescript
// app/entry.client.tsx
import { RemixBrowser } from '@remix-run/react';
import { startTransition, StrictMode, lazy, Suspense } from 'react';
import { hydrateRoot } from 'react-dom/client';

// ã‚³ãƒ¼ãƒ‰åˆ†å‰²
const App = lazy(() => import('./App'));

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <Suspense fallback={<div>Loading...</div>}>
        <RemixBrowser />
      </Suspense>
    </StrictMode>
  );
});
```

### 2. ç”»åƒãƒ»ã‚¢ã‚»ãƒƒãƒˆæœ€é©åŒ–

```typescript
// app/components/ui/OptimizedImage.tsx
interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  loading?: 'eager' | 'lazy';
}

export function OptimizedImage({ 
  src, 
  alt, 
  width, 
  height, 
  loading = 'lazy' 
}: OptimizedImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  
  return (
    <div className={`transition-opacity duration-300 ${isLoaded ? 'opacity-100' : 'opacity-0'}`}>
      <img
        src={src}
        alt={alt}
        width={width}
        height={height}
        loading={loading}
        decoding="async"
        onLoad={() => setIsLoaded(true)}
        className="max-w-full h-auto"
      />
    </div>
  );
}
```

## ğŸ“Š ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ»è¨ˆæ¸¬

### 1. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

#### ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹
```typescript
// src/common/monitoring/performance.service.ts
import { Injectable } from '@nestjs/common';
import { performance } from 'perf_hooks';

@Injectable()
export class PerformanceService {
  private metrics = new Map<string, number[]>();

  startTimer(name: string): string {
    const id = `${name}_${Date.now()}_${Math.random()}`;
    performance.mark(`${id}_start`);
    return id;
  }

  endTimer(id: string): number {
    performance.mark(`${id}_end`);
    performance.measure(id, `${id}_start`, `${id}_end`);
    
    const measure = performance.getEntriesByName(id)[0];
    const duration = measure.duration;
    
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
    const baseName = id.split('_')[0];
    if (!this.metrics.has(baseName)) {
      this.metrics.set(baseName, []);
    }
    
    this.metrics.get(baseName)!.push(duration);
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    performance.clearMarks(`${id}_start`);
    performance.clearMarks(`${id}_end`);
    performance.clearMeasures(id);
    
    return duration;
  }

  getStats(name: string) {
    const durations = this.metrics.get(name) || [];
    if (durations.length === 0) return null;
    
    const sorted = [...durations].sort((a, b) => a - b);
    return {
      count: durations.length,
      min: Math.min(...durations),
      max: Math.max(...durations),
      avg: durations.reduce((a, b) => a + b, 0) / durations.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p90: sorted[Math.floor(sorted.length * 0.9)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  }
}

// ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã®ä½¿ç”¨
export function Measure(name?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const metricName = name || `${target.constructor.name}.${propertyName}`;
    
    descriptor.value = async function (...args: any[]) {
      const performanceService = this.performanceService || 
        new (require('./performance.service').PerformanceService)();
      
      const timerId = performanceService.startTimer(metricName);
      
      try {
        const result = await originalMethod.apply(this, args);
        return result;
      } finally {
        performanceService.endTimer(timerId);
      }
    };
    
    return descriptor;
  };
}
```

### 2. ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–

```typescript
// src/common/monitoring/memory.service.ts
@Injectable()
export class MemoryMonitorService {
  private readonly logger = new Logger(MemoryMonitorService.name);
  private intervalId?: NodeJS.Timer;

  startMonitoring(intervalMs = 30000): void {
    this.intervalId = setInterval(() => {
      const usage = process.memoryUsage();
      const stats = {
        rss: Math.round(usage.rss / 1024 / 1024), // MB
        heapTotal: Math.round(usage.heapTotal / 1024 / 1024),
        heapUsed: Math.round(usage.heapUsed / 1024 / 1024),
        external: Math.round(usage.external / 1024 / 1024),
        timestamp: new Date().toISOString(),
      };

      this.logger.log(`Memory usage: ${JSON.stringify(stats)}`);

      // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã®è­¦å‘Š
      if (stats.heapUsed > 400) { // 400MB
        this.logger.warn(`High memory usage detected: ${stats.heapUsed}MB`);
      }
    }, intervalMs);
  }

  stopMonitoring(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
  }

  async getMemoryStats() {
    const usage = process.memoryUsage();
    return {
      rss: usage.rss,
      heapTotal: usage.heapTotal,
      heapUsed: usage.heapUsed,
      external: usage.external,
      heapUsedPercentage: (usage.heapUsed / usage.heapTotal) * 100,
    };
  }
}
```

## ğŸ”§ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

### 1. è² è·ãƒ†ã‚¹ãƒˆ

```typescript
// test/performance/load.test.ts
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';

describe('Load Testing', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç”Ÿæˆã®è² è·ãƒ†ã‚¹ãƒˆ', async () => {
    const concurrentRequests = 50;
    const requests = Array.from({ length: concurrentRequests }, () =>
      request(app.getHttpServer())
        .post('/api/generate/password')
        .send({
          length: 12,
          includeUpper: true,
          includeLower: true,
          includeNumbers: true,
          includeSymbols: false,
        })
        .expect(201)
    );

    const start = Date.now();
    const responses = await Promise.all(requests);
    const duration = Date.now() - start;

    expect(responses).toHaveLength(concurrentRequests);
    expect(duration).toBeLessThan(5000); // 5ç§’ä»¥å†…
    
    // å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒã‚§ãƒƒã‚¯
    const avgResponseTime = duration / concurrentRequests;
    expect(avgResponseTime).toBeLessThan(100); // 100msä»¥å†…
  });

  it('å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ', async () => {
    const start = Date.now();
    
    const response = await request(app.getHttpServer())
      .post('/api/generate/file')
      .send({
        format: 'csv',
        rowCount: 10000,
        schema: [
          { name: 'id', type: 'uuid' },
          { name: 'name', type: 'personalInfo.fullName' },
          { name: 'email', type: 'personalInfo.email' }
        ]
      })
      .expect(201);

    const duration = Date.now() - start;
    
    expect(duration).toBeLessThan(10000); // 10ç§’ä»¥å†…
    expect(response.body.downloadUrl).toBeDefined();
  }, 15000);
});
```

## ğŸ“‹ æœ€é©åŒ–ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Backendæœ€é©åŒ–
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­å®š
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®å®Ÿè£…
- [ ] å¤§å®¹é‡å‡¦ç†ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å¯¾å¿œ  
- [ ] ä¸¦åˆ—å‡¦ç†ã®æ´»ç”¨
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®é˜²æ­¢
- [ ] ä¸è¦ãªãƒ­ã‚°ã®å‰Šé™¤

### Frontendæœ€é©åŒ–  
- [ ] ã‚³ãƒ¼ãƒ‰åˆ†å‰²ã®å®Ÿè£…
- [ ] ç”»åƒãƒ»ã‚¢ã‚»ãƒƒãƒˆã®æœ€é©åŒ–
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®è¨­å®š
- [ ] é…å»¶ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å®Ÿè£…
- [ ] ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã®æœ€é©åŒ–

### ã‚¤ãƒ³ãƒ•ãƒ©æœ€é©åŒ–
- [ ] ãƒªãƒãƒ¼ã‚¹ãƒ—ãƒ­ã‚­ã‚·ã®è¨­å®š
- [ ] é™çš„ãƒ•ã‚¡ã‚¤ãƒ«ã®CDNé…ä¿¡
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°
- [ ] ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã®è¨­å®š
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆã®è¨­å®š

### ç¶™ç¶šçš„æœ€é©åŒ–
- [ ] å®šæœŸçš„ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ã®å®Ÿæ–½
- [ ] ãƒœãƒˆãƒ«ãƒãƒƒã‚¯åˆ†æ
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®åé›†
- [ ] æœ€é©åŒ–åŠ¹æœã®æ¸¬å®š 