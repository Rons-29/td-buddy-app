# TestData Buddy パフォーマンス最適化ガイド

## 🎯 パフォーマンス目標

### レスポンス時間目標
- **パスワード生成**: < 100ms
- **小規模テキスト生成** (< 1KB): < 200ms  
- **個人情報生成** (< 100件): < 500ms
- **小規模ファイル生成** (< 1MB): < 1秒
- **大規模ファイル生成** (< 100MB): < 30秒
- **Claude API 呼び出し**: < 3秒

### リソース使用量目標
- **メモリ使用量**: < 512MB (通常時)
- **CPU使用率**: < 70% (ピーク時)
- **ディスク使用量**: < 1GB (一時ファイル含む)

## 🚀 Backend最適化

### 1. データベース最適化

#### SQLite チューニング
```typescript
// src/config/database.config.ts
import { TypeOrmModuleOptions } from '@nestjs/typeorm';

export const databaseConfig: TypeOrmModuleOptions = {
  type: 'sqlite',
  database: './data/td-buddy.sqlite',
  entities: ['dist/**/*.entity{.ts,.js}'],
  synchronize: false,
  
  // パフォーマンス最適化設定
  extra: {
    // WALモード（書き込み性能向上）
    pragma: {
      journal_mode: 'WAL',
      synchronous: 'NORMAL',
      cache_size: -64000, // 64MB キャッシュ
      temp_store: 'MEMORY',
      mmap_size: 268435456, // 256MB mmap
    }
  },
  
  // 接続プール設定
  poolSize: 10,
  keepConnectionAlive: true,
  
  // ログ設定（本番では無効化）
  logging: process.env.NODE_ENV === 'development' ? 'all' : false,
};
```

#### インデックス最適化
```sql
-- 履歴テーブルのインデックス
CREATE INDEX idx_generation_history_type ON generation_history(type);
CREATE INDEX idx_generation_history_created_at ON generation_history(created_at);
CREATE INDEX idx_generation_history_user_id ON generation_history(user_id);

-- 複合インデックス
CREATE INDEX idx_generation_history_user_type_date 
ON generation_history(user_id, type, created_at);

-- ファイルテンプレートのインデックス  
CREATE INDEX idx_file_template_type ON file_template(type);
```

### 2. キャッシュ戦略

#### Redis キャッシュ実装
```typescript
// src/common/cache/cache.service.ts
import { Injectable } from '@nestjs/common';
import { Redis } from 'ioredis';

@Injectable()
export class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
    });
  }

  async get<T>(key: string): Promise<T | null> {
    try {
      const cached = await this.redis.get(key);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      console.warn(`Cache get error for key ${key}:`, error);
      return null;
    }
  }

  async set(key: string, value: any, ttlSeconds = 3600): Promise<void> {
    try {
      await this.redis.setex(key, ttlSeconds, JSON.stringify(value));
    } catch (error) {
      console.warn(`Cache set error for key ${key}:`, error);
    }
  }

  async del(key: string): Promise<void> {
    try {
      await this.redis.del(key);
    } catch (error) {
      console.warn(`Cache delete error for key ${key}:`, error);
    }
  }

  // パターンベースの削除
  async deletePattern(pattern: string): Promise<void> {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

#### メモリキャッシュ実装
```typescript
// src/common/cache/memory-cache.service.ts
import { Injectable } from '@nestjs/common';
import NodeCache from 'node-cache';

@Injectable()
export class MemoryCacheService {
  private cache: NodeCache;

  constructor() {
    this.cache = new NodeCache({
      stdTTL: 600, // 10分デフォルトTTL
      checkperiod: 120, // 2分毎にクリーンアップ
      maxKeys: 1000, // 最大キー数
    });
  }

  get<T>(key: string): T | undefined {
    return this.cache.get<T>(key);
  }

  set(key: string, value: any, ttl?: number): boolean {
    return this.cache.set(key, value, ttl || 600);
  }

  del(key: string): number {
    return this.cache.del(key);
  }

  flush(): void {
    this.cache.flushAll();
  }

  getStats() {
    return this.cache.getStats();
  }
}
```

### 3. 非同期処理・ストリーミング

#### 大容量ファイル生成最適化
```typescript
// src/modules/file/file-stream.service.ts
import { Injectable } from '@nestjs/common';
import { Transform, Writable } from 'stream';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';

@Injectable()
export class FileStreamService {
  
  async generateLargeCSV(config: FileGenerationConfig): Promise<string> {
    const outputPath = this.getOutputPath(config);
    const writeStream = createWriteStream(outputPath);
    
    // CSVヘッダー書き込み
    writeStream.write(this.generateCSVHeader(config.schema) + '\n');
    
    // データ生成用のトランスフォームストリーム
    const dataGenerator = new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        const row = this.generateDataRow(config.schema);
        const csvRow = this.formatCSVRow(row);
        callback(null, csvRow + '\n');
      }.bind(this)
    });

    // バッチ処理用のストリーム
    const batchStream = new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        // 1000行ずつバッチ処理
        const batch = Array.from({ length: 1000 }, (_, i) => i);
        batch.forEach(row => this.push(row));
        callback();
      }
    });

    try {
      await pipeline(
        this.createNumberStream(config.rowCount),
        batchStream,
        dataGenerator,
        writeStream
      );
      
      return outputPath;
    } catch (error) {
      throw new Error(`ファイル生成に失敗しました: ${error.message}`);
    }
  }

  private createNumberStream(count: number) {
    return new Transform({
      objectMode: true,
      transform(chunk, encoding, callback) {
        for (let i = 0; i < count; i += 1000) {
          this.push(i);
        }
        callback();
      }
    });
  }
}
```

### 4. 並列処理最適化

#### Worker Threads活用
```typescript
// src/modules/worker/worker.service.ts
import { Injectable } from '@nestjs/common';
import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { cpus } from 'os';

@Injectable()
export class WorkerService {
  private readonly maxWorkers = cpus().length;

  async processInParallel<T, R>(
    items: T[],
    processingFunction: (item: T) => R,
    chunkSize?: number
  ): Promise<R[]> {
    
    const chunks = this.chunkArray(items, chunkSize || Math.ceil(items.length / this.maxWorkers));
    const workers: Promise<R[]>[] = [];

    for (const chunk of chunks) {
      const workerPromise = new Promise<R[]>((resolve, reject) => {
        const worker = new Worker(__filename, {
          workerData: { chunk, functionString: processingFunction.toString() }
        });

        worker.on('message', resolve);
        worker.on('error', reject);
        worker.on('exit', (code) => {
          if (code !== 0) {
            reject(new Error(`Worker stopped with exit code ${code}`));
          }
        });
      });

      workers.push(workerPromise);
    }

    const results = await Promise.all(workers);
    return results.flat();
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
}

// ワーカースレッド処理
if (!isMainThread) {
  const { chunk, functionString } = workerData;
  const processingFunction = new Function('return ' + functionString)();
  
  const results = chunk.map(processingFunction);
  parentPort?.postMessage(results);
}
```

## 🎨 Frontend最適化

### 1. Remix最適化

#### ローダー最適化
```typescript
// app/routes/password.tsx
import type { LoaderFunctionArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { useLoaderData, useFetcher } from '@remix-run/react';

export async function loader({ request }: LoaderFunctionArgs) {
  // キャッシュヘッダー設定
  const headers = new Headers();
  headers.set('Cache-Control', 'public, max-age=300'); // 5分キャッシュ

  // 必要最小限のデータのみ取得
  const config = await getPasswordConfig();
  
  return json({ config }, { headers });
}

// コンポーネント最適化
export default function PasswordPage() {
  const { config } = useLoaderData<typeof loader>();
  const fetcher = useFetcher();
  
  // debounceされた生成関数
  const debouncedGenerate = useMemo(
    () => debounce((formData: FormData) => {
      fetcher.submit(formData, { method: 'post' });
    }, 300),
    [fetcher]
  );

  return (
    <div className="space-y-6">
      <PasswordForm onSubmit={debouncedGenerate} />
      {fetcher.data && <PasswordResult data={fetcher.data} />}
    </div>
  );
}
```

#### バンドル最適化
```typescript
// app/entry.client.tsx
import { RemixBrowser } from '@remix-run/react';
import { startTransition, StrictMode, lazy, Suspense } from 'react';
import { hydrateRoot } from 'react-dom/client';

// コード分割
const App = lazy(() => import('./App'));

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <Suspense fallback={<div>Loading...</div>}>
        <RemixBrowser />
      </Suspense>
    </StrictMode>
  );
});
```

### 2. 画像・アセット最適化

```typescript
// app/components/ui/OptimizedImage.tsx
interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  loading?: 'eager' | 'lazy';
}

export function OptimizedImage({ 
  src, 
  alt, 
  width, 
  height, 
  loading = 'lazy' 
}: OptimizedImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  
  return (
    <div className={`transition-opacity duration-300 ${isLoaded ? 'opacity-100' : 'opacity-0'}`}>
      <img
        src={src}
        alt={alt}
        width={width}
        height={height}
        loading={loading}
        decoding="async"
        onLoad={() => setIsLoaded(true)}
        className="max-w-full h-auto"
      />
    </div>
  );
}
```

## 📊 モニタリング・計測

### 1. パフォーマンス監視

#### カスタムメトリクス
```typescript
// src/common/monitoring/performance.service.ts
import { Injectable } from '@nestjs/common';
import { performance } from 'perf_hooks';

@Injectable()
export class PerformanceService {
  private metrics = new Map<string, number[]>();

  startTimer(name: string): string {
    const id = `${name}_${Date.now()}_${Math.random()}`;
    performance.mark(`${id}_start`);
    return id;
  }

  endTimer(id: string): number {
    performance.mark(`${id}_end`);
    performance.measure(id, `${id}_start`, `${id}_end`);
    
    const measure = performance.getEntriesByName(id)[0];
    const duration = measure.duration;
    
    // メトリクス記録
    const baseName = id.split('_')[0];
    if (!this.metrics.has(baseName)) {
      this.metrics.set(baseName, []);
    }
    
    this.metrics.get(baseName)!.push(duration);
    
    // クリーンアップ
    performance.clearMarks(`${id}_start`);
    performance.clearMarks(`${id}_end`);
    performance.clearMeasures(id);
    
    return duration;
  }

  getStats(name: string) {
    const durations = this.metrics.get(name) || [];
    if (durations.length === 0) return null;
    
    const sorted = [...durations].sort((a, b) => a - b);
    return {
      count: durations.length,
      min: Math.min(...durations),
      max: Math.max(...durations),
      avg: durations.reduce((a, b) => a + b, 0) / durations.length,
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p90: sorted[Math.floor(sorted.length * 0.9)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  }
}

// デコレーターでの使用
export function Measure(name?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const metricName = name || `${target.constructor.name}.${propertyName}`;
    
    descriptor.value = async function (...args: any[]) {
      const performanceService = this.performanceService || 
        new (require('./performance.service').PerformanceService)();
      
      const timerId = performanceService.startTimer(metricName);
      
      try {
        const result = await originalMethod.apply(this, args);
        return result;
      } finally {
        performanceService.endTimer(timerId);
      }
    };
    
    return descriptor;
  };
}
```

### 2. メモリ使用量監視

```typescript
// src/common/monitoring/memory.service.ts
@Injectable()
export class MemoryMonitorService {
  private readonly logger = new Logger(MemoryMonitorService.name);
  private intervalId?: NodeJS.Timer;

  startMonitoring(intervalMs = 30000): void {
    this.intervalId = setInterval(() => {
      const usage = process.memoryUsage();
      const stats = {
        rss: Math.round(usage.rss / 1024 / 1024), // MB
        heapTotal: Math.round(usage.heapTotal / 1024 / 1024),
        heapUsed: Math.round(usage.heapUsed / 1024 / 1024),
        external: Math.round(usage.external / 1024 / 1024),
        timestamp: new Date().toISOString(),
      };

      this.logger.log(`Memory usage: ${JSON.stringify(stats)}`);

      // メモリ使用量が閾値を超えた場合の警告
      if (stats.heapUsed > 400) { // 400MB
        this.logger.warn(`High memory usage detected: ${stats.heapUsed}MB`);
      }
    }, intervalMs);
  }

  stopMonitoring(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
  }

  async getMemoryStats() {
    const usage = process.memoryUsage();
    return {
      rss: usage.rss,
      heapTotal: usage.heapTotal,
      heapUsed: usage.heapUsed,
      external: usage.external,
      heapUsedPercentage: (usage.heapUsed / usage.heapTotal) * 100,
    };
  }
}
```

## 🔧 パフォーマンステスト

### 1. 負荷テスト

```typescript
// test/performance/load.test.ts
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';

describe('Load Testing', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it('パスワード生成の負荷テスト', async () => {
    const concurrentRequests = 50;
    const requests = Array.from({ length: concurrentRequests }, () =>
      request(app.getHttpServer())
        .post('/api/generate/password')
        .send({
          length: 12,
          includeUpper: true,
          includeLower: true,
          includeNumbers: true,
          includeSymbols: false,
        })
        .expect(201)
    );

    const start = Date.now();
    const responses = await Promise.all(requests);
    const duration = Date.now() - start;

    expect(responses).toHaveLength(concurrentRequests);
    expect(duration).toBeLessThan(5000); // 5秒以内
    
    // 平均レスポンス時間チェック
    const avgResponseTime = duration / concurrentRequests;
    expect(avgResponseTime).toBeLessThan(100); // 100ms以内
  });

  it('大容量ファイル生成のパフォーマンステスト', async () => {
    const start = Date.now();
    
    const response = await request(app.getHttpServer())
      .post('/api/generate/file')
      .send({
        format: 'csv',
        rowCount: 10000,
        schema: [
          { name: 'id', type: 'uuid' },
          { name: 'name', type: 'personalInfo.fullName' },
          { name: 'email', type: 'personalInfo.email' }
        ]
      })
      .expect(201);

    const duration = Date.now() - start;
    
    expect(duration).toBeLessThan(10000); // 10秒以内
    expect(response.body.downloadUrl).toBeDefined();
  }, 15000);
});
```

## 📋 最適化チェックリスト

### Backend最適化
- [ ] データベースインデックスの設定
- [ ] キャッシュ戦略の実装
- [ ] 大容量処理のストリーミング対応  
- [ ] 並列処理の活用
- [ ] メモリリークの防止
- [ ] 不要なログの削除

### Frontend最適化  
- [ ] コード分割の実装
- [ ] 画像・アセットの最適化
- [ ] キャッシュ戦略の設定
- [ ] 遅延ローディングの実装
- [ ] バンドルサイズの最適化

### インフラ最適化
- [ ] リバースプロキシの設定
- [ ] 静的ファイルのCDN配信
- [ ] データベースのチューニング
- [ ] モニタリングの設定
- [ ] アラートの設定

### 継続的最適化
- [ ] 定期的なパフォーマンステスト
- [ ] プロファイリングの実施
- [ ] ボトルネック分析
- [ ] ユーザーフィードバックの収集
- [ ] 最適化効果の測定 